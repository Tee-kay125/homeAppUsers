#!/usr/bin/env python3.6
# -*- coding: utf-8 -*-
"""-----------------------------------------------------------------------------

Company  : Reutech Radar Systems
Designer : T Ramukosi
Mentor   : J Taylor
Generated: 2018-08-30
--------------------------------------------------------------------------------

Description:

read autogenerated classes and parse to json structure
-----------------------------------------------------------------------------"""
import inspect
import sys, os, json
from Codegen import Codegen_Python
from Codegen.Codegen_Python import Generated_Python
from Codegen.Codegen_Python.Generated_Python import *
from Codegen.Codegen_Python import change_ini_path
from Codegen.Codegen_Python import Generated_Python
import importlib
from shutil import copyfile
from collections import OrderedDict
import logging
from enum import Enum
import xml.etree.ElementTree as ET
import clVariables
import server
from Comms import Protocol_class as _Protocol_class
import copy

iMessageLength = int()
G_dctInterfaceMessages = OrderedDict()

def generateJsonWithInterface(acPipeNamePar,acMQTTRemoteIpPar, acMQTTPortPar ,acZeroMQRemoteIpPar, acZeroMQPortPar, acZeroMQRemoteIpParPub, acZeroMQPortParPub, lstxmlsPar, lstInterfaceXmlsPar, pubSubTagSwap, acXmlSchemaPar):
    """ This function add new connection to the json file holding all messages

    Parameters:
        pipe (str): The name of the pipe
        protocol (str): The name of the protocol
        RemoteIP (str): The IP of the broker for MQTT
        xmls (list): A list of XML files
        SystemName (str): The name of the system
        Destination (list): A list with the destination inside


    Returns:

    Raises:
        Raises no exceptions

    """
    global iMessageLength
    MsgName = str()
    acModuleAddress = ''
    acScript = str("")  # The full path of the autogen script
    acIniFile = str("")  # The full path of the ini file required by the autogen script
    iADCSHeaderLength = 20
    iBR12HeaderLength = 8
    acxmlSchema = str()
    acPathToSICD = os.path.join(os.path.dirname(__file__), "../../SICD/")
    lstFiles = os.listdir(acPathToSICD)
    G_dctInterfaceMessages = OrderedDict()
    G_dctInterfaceMessages.update({"Publish":{},"Subscribe":{}})
    bUseMQTT = True
    bUseZMQPub = True
    bUseZMQSub = True

    """
        check which message protocol is selected
    """
    if not acMQTTRemoteIpPar and not acMQTTPortPar:
        bUseMQTT = False
    if not acZeroMQRemoteIpParPub and not acZeroMQPortParPub:
        bUseZMQPub = False
    if not acZeroMQRemoteIpPar and not acZeroMQPortPar:
        bUseZMQSub = False

    """
        loop through all config files and get individual message protocol, module and topics
    """
    for i in range(len(lstFiles)):
        if lstFiles[i] in lstInterfaceXmlsPar:
            try:
                acTree = ET.parse(os.path.join(os.path.dirname(__file__),"../../SICD/" + lstFiles[i]))
                objRoot = acTree.getroot()
                acxmlSchema = objRoot.attrib['System']
                for pubSub in objRoot:
                    for Topic in pubSub:
                        acSystem    = Topic.attrib['System']
                        acModule    = Topic.attrib['Name']
                        for msg in Topic:
                            acMsgName   = msg.attrib['Name']
                            acProtocol  = msg.attrib['Protocol']
                            acPubSubTag = str()
                            if pubSubTagSwap == "on":
                                if pubSub.tag == "Publish":
                                    acPubSubTag = "Subscribe"
                                else:
                                    acPubSubTag = "Publish"
                            else:
                                acPubSubTag = pubSub.tag
                            G_dctInterfaceMessages[acPubSubTag].update({acMsgName:[acSystem, acModule, acProtocol,acMsgName, acPubSubTag]})
            except Exception as E:
                logging.error("unable to open the Interface file, Error -> %s",E)
                return

    '''
        Loop through given xmls, change the ini path to the given xml and execute the autogen
    '''
    if acXmlSchemaPar == "ADCS":
        for xmlFile in lstxmlsPar:

            """
                change ini content are changed everytime a new xml is added, we use reload to try 
                out new changes without leaving the python intepreter, and execute the autogen script
            """
            
            acSystemNameForInterface = acxmlSchema
            acXmlSchemaForInterface = acxmlSchema

            importlib.reload(change_ini_path)
            change_ini_path.change_ini(xmlFile, acSystemNameForInterface, acXmlSchemaForInterface)
            
            acScript = os.path.join(os.path.dirname(__file__), "autogen_python.py")
            acIniFile = os.path.join(os.path.dirname(__file__), "autogen_python_config.ini")
            os.system('python3.6 ' + acScript + ' ' + acIniFile)

        '''
            Read the generated MsgDef file and   create a dictionary.
        '''

        acPathToGenFolder = os.path.join(os.path.dirname(__file__), "Generated_Python/")
        lstFiles = os.listdir(acPathToGenFolder)

        for i in range(len(lstFiles)):
            if lstFiles[i].endswith('MsgDef.py'):
                dctMsgs = {}
                dctMsgs["Connection"] = {}
                dctMsgs["Connection"]["PipeName"] = str("")
                dctMsgs["Connection"]["Protocol"] = str("")
                dctMsgs["Connection"]["MQTTRemoteIP"] = str("")
                dctMsgs["Connection"]["MQTTPort"] = str("")
                dctMsgs["Connection"]["ZeroMQRemoteIP"] = str("")
                dctMsgs["Connection"]["ZeroMQPort"] = str("")
                dctMsgs["Connection"]["ZeroMQRemoteIPPub"] = str("")
                dctMsgs["Connection"]["ZeroMQPortPub"] = str("")
                dctMsgs["Connection"]["xmlFile"] = str("")
                dctMsgs["Connection"]["SystemName"] = str("")
                dctMsgs["Connection"]["xmlSchema"] = str("")
                dctMsgs["Connection"]["Destination"] = str("")
                dctMsgs["Messages"] = {}

                lstClassContents = []

                try:
                    objNewModule = importlib.import_module("Codegen.Codegen_Python.Generated_Python.%s" % (lstFiles[i][:-3]))
                except Exception as E:
                    logging.error("Could not import_module %s error -> %s", 'Generated_Python.' + lstFiles[i][:-3], E)
                    continue

                # inspect a class, get its content, and append it to a list
                for acName, clsClassContent in inspect.getmembers(objNewModule):
                    if inspect.isclass(clsClassContent):
                        if(
                            acName.endswith("MsgCls")
                        ):
                            lstClassContents.append(clsClassContent)

                # create object of each inspected class and get its content 
                for clsClassContent in lstClassContents:
                    try:
                        objClassContent = clsClassContent()
                    except Exception as E:
                        logging.error("Cant create the object of this xml error -> %s", E)
                        return

                    try:
                        MsgName             = objClassContent.__class__.__name__[1:-6]
                        MsgType = objClassContent.sMsgHeader.e2MsgType.Value
                        acTempModuleAddress = objClassContent.sMsgHeader.e2ModuleAddress.Value
                        acModuleAddress = acTempModuleAddress
                        MsgId = objClassContent.sMsgHeader.u2MsgId.Value
                        acMsgCount = objClassContent.sMsgHeader.u2MsgCount.Value
                        acTimeStampMs = objClassContent.sMsgHeader.u8TimeStampMs.Value
                        acProcessStartCnt = objClassContent.sMsgHeader.u2ProcessStartCnt.Value
                    except Exception as E:
                        logging.error('error reading xml object, error -> %s', E)
                        return

                    bPublishTag = False
                    bSubscribeTag = False
                    try:
                        if MsgName in G_dctInterfaceMessages["Publish"]:
                            if G_dctInterfaceMessages["Publish"][MsgName][2] == "MQTT" and bUseMQTT or G_dctInterfaceMessages["Publish"][MsgName][2] == "ZMQ" and bUseZMQPub:
                                bPublishTag = True
                                dctMsgs["Connection"]["PipeName"] = acPipeNamePar
                                dctMsgs["Connection"]["Protocol"] = G_dctInterfaceMessages["Publish"][MsgName][2]
                                dctMsgs["Connection"]["MQTTRemoteIP"] = acMQTTRemoteIpPar
                                dctMsgs["Connection"]["MQTTPort"] = acMQTTPortPar
                                dctMsgs["Connection"]["ZeroMQRemoteIP"] = acZeroMQRemoteIpPar
                                dctMsgs["Connection"]["ZeroMQPort"] = acZeroMQPortPar
                                dctMsgs["Connection"]["ZeroMQRemoteIPPub"] = acZeroMQRemoteIpParPub
                                dctMsgs["Connection"]["ZeroMQPortPub"] = acZeroMQPortParPub
                                dctMsgs["Connection"]["xmlFile"] = lstFiles[i][:-3]
                                dctMsgs["Connection"]["SystemName"] = G_dctInterfaceMessages["Publish"][MsgName][0]
                                dctMsgs["Connection"]["xmlSchema"] = acXmlSchemaForInterface
                                dctMsgs["Connection"]["Destination"] = G_dctInterfaceMessages["Publish"][MsgName][1]

                                dctMsgs['Messages'].update({"{}_{}_{}".format(MsgId, acTempModuleAddress, MsgType): {
                                    'Name': MsgName,
                                    'Msg_Topic': str(),
                                    'Msg_Topic_Sub':str(),
                                    'Individual_Message_Protocol':G_dctInterfaceMessages["Publish"][MsgName][2],
                                    'pubSub_tag':str(),
                                    'pubSub_tag_Sub':str(),
                                    'payloadtypes':str(''.join(recursiveGetPayloadType(list(), objClassContent.sPayload))),
                                    'Header': {
                                        'MsgLength': objClassContent.sMsgHeader.u2MsgLength.Value,
                                        'MsgType': MsgType,
                                        'MsgStatus': objClassContent.sMsgHeader.e2MsgStatus.Value,
                                        'ModuleAddress': acTempModuleAddress,
                                        'MsgId': MsgId,
                                        'MsgCount': acMsgCount,
                                        'TimeStampMs': acTimeStampMs,
                                        'ProcessStartCnt': acProcessStartCnt                          
                                        },
                                    'Payload': objClassContent.sPayload}})

                                iMessageLength = iADCSHeaderLength
                                try:
                                    dctMsgs['Messages'][str(MsgId) + '_' + str(acTempModuleAddress) + '_' + str(MsgType)]['Header']['MsgLength'] = int(iGetSize(objClassContent.sPayload))
                                except Exception as E:
                                    logging.error("Unable to update the message length, error -> %s", E)


                                lstRoles = objClassContent.roles.split(",")
                                if len(lstRoles) > 1:
                                    if lstRoles:
                                        for role in lstRoles:
                                            dctMsgs['Messages'].update({"{}_{}_{}_{}".format(MsgId, acTempModuleAddress, MsgType, role): {
                                                'Name': MsgName + '_' + role,
                                                'Msg_Topic': str(),
                                                'Msg_Topic_Sub':str(),
                                                'Individual_Message_Protocol':G_dctInterfaceMessages["Publish"][MsgName][2],
                                                'pubSub_tag':str(),
                                                'pubSub_tag_Sub':str(),
                                                'payloadtypes':str(''.join(recursiveGetPayloadType(list(), objClassContent.sPayload))),
                                                'Header': {
                                                    'MsgLength': objClassContent.sMsgHeader.u2MsgLength.Value,
                                                    'MsgType': MsgType,
                                                    'MsgStatus': objClassContent.sMsgHeader.e2MsgStatus.Value,
                                                    'ModuleAddress': acTempModuleAddress,
                                                    'MsgId': MsgId,
                                                    'MsgCount': acMsgCount,
                                                    'TimeStampMs': acTimeStampMs,
                                                    'ProcessStartCnt': acProcessStartCnt                          
                                                    },
                                                'Payload': objClassContent.sPayload}})
                                            
                                            iMessageLength = iADCSHeaderLength
                                            try:
                                                dctMsgs['Messages'][str(MsgId) + '_' + str(acTempModuleAddress) + '_' + str(MsgType) + '_' + role]['Header']['MsgLength'] = int(iGetSize(objClassContent.sPayload))
                                            except Exception as E:
                                                logging.error("Unable to update the message length, error -> %s", E)
                        
                        if MsgName in G_dctInterfaceMessages["Subscribe"]:
                            if G_dctInterfaceMessages["Subscribe"][MsgName][2] == "MQTT" and bUseMQTT or G_dctInterfaceMessages["Subscribe"][MsgName][2] == "ZMQ" and bUseZMQSub:      
                                bSubscribeTag = True
                                dctMsgs["Connection"]["PipeName"] = acPipeNamePar
                                dctMsgs["Connection"]["Protocol"] = G_dctInterfaceMessages["Subscribe"][MsgName][2]
                                dctMsgs["Connection"]["MQTTRemoteIP"] = acMQTTRemoteIpPar
                                dctMsgs["Connection"]["MQTTPort"] = acMQTTPortPar
                                dctMsgs["Connection"]["ZeroMQRemoteIP"] = acZeroMQRemoteIpPar
                                dctMsgs["Connection"]["ZeroMQPort"] = acZeroMQPortPar
                                dctMsgs["Connection"]["ZeroMQRemoteIPPub"] = acZeroMQRemoteIpParPub
                                dctMsgs["Connection"]["ZeroMQPortPub"] = acZeroMQPortParPub
                                dctMsgs["Connection"]["xmlFile"] = lstFiles[i][:-3]
                                dctMsgs["Connection"]["SystemName"] = G_dctInterfaceMessages["Subscribe"][MsgName][0]
                                dctMsgs["Connection"]["xmlSchema"] = acXmlSchemaForInterface
                                dctMsgs["Connection"]["Destination"] = G_dctInterfaceMessages["Subscribe"][MsgName][1]

                                dctMsgs['Messages'].update({"{}_{}_{}".format(MsgId, acTempModuleAddress, MsgType): {
                                    'Name': MsgName,
                                    'Msg_Topic': str(),
                                    'Msg_Topic_Sub':str(),
                                    'Individual_Message_Protocol':G_dctInterfaceMessages["Subscribe"][MsgName][2],
                                    'pubSub_tag':str(),
                                    'pubSub_tag_Sub':str(),
                                    'payloadtypes':str(''.join(recursiveGetPayloadType(list(), objClassContent.sPayload))),
                                    'Header': {
                                        'MsgLength': objClassContent.sMsgHeader.u2MsgLength.Value,
                                        'MsgType': MsgType,
                                        'MsgStatus': objClassContent.sMsgHeader.e2MsgStatus.Value,
                                        'ModuleAddress': acTempModuleAddress,
                                        'MsgId': MsgId,
                                        'MsgCount': acMsgCount,
                                        'TimeStampMs': acTimeStampMs,
                                        'ProcessStartCnt': acProcessStartCnt                          
                                        },
                                    'Payload': objClassContent.sPayload}})

                                iMessageLength = iADCSHeaderLength
                                try:
                                    dctMsgs['Messages'][str(MsgId) + '_' + str(acTempModuleAddress) + '_' + str(MsgType)]['Header']['MsgLength'] = int(iGetSize(objClassContent.sPayload))
                                except Exception as E:
                                    logging.error("Unable to update the message length, error -> %s", E)

                                lstRoles = objClassContent.roles.split(",")
                                if len(lstRoles) > 1:
                                    if lstRoles:
                                        for role in lstRoles:
                                            dctMsgs['Messages'].update({"{}_{}_{}_{}".format(MsgId, acTempModuleAddress, MsgType, role): {
                                                'Name': MsgName + '_' + role,
                                                'Msg_Topic': str(),
                                                'Msg_Topic_Sub':str(),
                                                'Individual_Message_Protocol':G_dctInterfaceMessages["Subscribe"][MsgName][2],
                                                'pubSub_tag':str(),
                                                'pubSub_tag_Sub':str(),
                                                'payloadtypes':str(''.join(recursiveGetPayloadType(list(), objClassContent.sPayload))),
                                                'Header': {
                                                    'MsgLength': objClassContent.sMsgHeader.u2MsgLength.Value,
                                                    'MsgType': MsgType,
                                                    'MsgStatus': objClassContent.sMsgHeader.e2MsgStatus.Value,
                                                    'ModuleAddress': acTempModuleAddress,
                                                    'MsgId': MsgId,
                                                    'MsgCount': acMsgCount,
                                                    'TimeStampMs': acTimeStampMs,
                                                    'ProcessStartCnt': acProcessStartCnt                          
                                                    },
                                                'Payload': objClassContent.sPayload}})
                                            
                                            iMessageLength = iADCSHeaderLength
                                            try:
                                                dctMsgs['Messages'][str(MsgId) + '_' + str(acTempModuleAddress) + '_' + str(MsgType) + '_' + role]['Header']['MsgLength'] = int(iGetSize(objClassContent.sPayload))
                                            except Exception as E:
                                                logging.error("Unable to update the message length, error -> %s", E)


                        lstRoles = objClassContent.roles.split(",")
                        if bPublishTag:
                            acID = str(MsgId) + "_" + str(acTempModuleAddress) + "_" + str(MsgType)
                            dctMsgs['Messages'][acID]["Msg_Topic"] = G_dctInterfaceMessages["Publish"][MsgName][0] + '/' + G_dctInterfaceMessages["Publish"][MsgName][1] + '/' + MsgName
                            dctMsgs['Messages'][acID]["pubSub_tag"] = G_dctInterfaceMessages["Publish"][MsgName][4]
                            if len(lstRoles) > 1:
                                if lstRoles:
                                    for role in lstRoles:
                                        acID = str(MsgId) + "_" + str(acTempModuleAddress) + "_" + str(MsgType) + "_" + str(role)
                                        dctMsgs['Messages'][acID]["Msg_Topic"] = G_dctInterfaceMessages["Publish"][MsgName][0] + '/' + G_dctInterfaceMessages["Publish"][MsgName][1] + '/' + MsgName +'/'+role
                                        dctMsgs['Messages'][acID]["pubSub_tag"] = G_dctInterfaceMessages["Publish"][MsgName][4]
                            

                        if bSubscribeTag:
                            acID = str(MsgId) + "_" + str(acTempModuleAddress) + "_" + str(MsgType)
                            dctMsgs['Messages'][acID]["Msg_Topic_Sub"] = G_dctInterfaceMessages["Subscribe"][MsgName][0] + '/' + G_dctInterfaceMessages["Subscribe"][MsgName][1] + '/' + MsgName
                            dctMsgs['Messages'][acID]["pubSub_tag_Sub"] = G_dctInterfaceMessages["Subscribe"][MsgName][4]
                            if len(lstRoles) > 1:
                                if lstRoles:
                                    for role in lstRoles:
                                        acID = str(MsgId) + "_" + str(acTempModuleAddress) + "_" + str(MsgType) + "_" + str(role)
                                        dctMsgs['Messages'][acID]["Msg_Topic_Sub"] = G_dctInterfaceMessages["Subscribe"][MsgName][0] + '/' + G_dctInterfaceMessages["Subscribe"][MsgName][1] + '/' + MsgName +'/'+role
                                        dctMsgs['Messages'][acID]["pubSub_tag_Sub"] = G_dctInterfaceMessages["Subscribe"][MsgName][4]

                    except Exception as E:
                        logging.error("Could not read the message protocol from the dictionary, Error -> %s", E)
                    
                dctMsgsCopy = copy.deepcopy(dctMsgs)
                _Protocol_class.G_dctJsonFile['xmls'].append(dctMsgsCopy)
                _Protocol_class.G_dctJsonFileSender['xmls'].append(dctMsgsCopy)


        newPipes = copy.deepcopy({str(acModuleAddress):{'name':acPipeNamePar,'xmls':lstxmlsPar}})
        _Protocol_class.G_dctPipes.update(newPipes)

        try:
            _Protocol_class.G_dctJsonFile = OrderedDict(json.loads(json.dumps(_Protocol_class.G_dctJsonFile)))
            _Protocol_class.G_dctJsonFileSender = OrderedDict(json.loads(json.dumps(_Protocol_class.G_dctJsonFileSender)))
        except Exception as E:
            logging.error("Could not convert dictionary to json string and back to dictionary, Error -> %s", E)

        #---------------------------------------------------------------------------------------------------------------------
    elif acXmlSchemaPar == "BR12":
        for xmlFile in lstxmlsPar:

            
            '''
                change ini content are changed everytime a new xml is added, we use reload to try 
                out new changes without leaving the python intepreter, and execute the autogen script
            '''
            acSystemNameForInterface = acxmlSchema
            acXmlSchemaForInterface = acxmlSchema

            importlib.reload(change_ini_path)
            change_ini_path.change_ini(xmlFile, acSystemNameForInterface, acXmlSchemaForInterface)
            
            acScript = os.path.join(os.path.dirname(__file__), "autogen_python.py")
            acIniFile = os.path.join(os.path.dirname(__file__), "autogen_python_config.ini")
            os.system('python3.6 ' + acScript + ' ' + acIniFile)

        '''
            Read the generated MsgDef file and   create a dictionary.
        '''

        acPathToGenFolder = os.path.join(os.path.dirname(__file__), "Generated_Python/")
        lstFiles = os.listdir(acPathToGenFolder)

        bUseMQTT = True
        bUseZMQPub = True
        bUseZMQSub = True

        """
            check which message protocol is selected
        """
        if not acMQTTRemoteIpPar and not acMQTTPortPar:
            bUseMQTT = False
        if not acZeroMQRemoteIpParPub and not acZeroMQPortParPub:
            bUseZMQPub = False
        if not acZeroMQRemoteIpPar and not acZeroMQPortPar:
            bUseZMQSub = False

        for i in range(len(lstFiles)):
            if lstFiles[i].endswith('MsgDef.py'):
                dctMsgs = {}
                dctMsgs["Connection"] = {}
                dctMsgs["Connection"]["PipeName"] = str("")
                dctMsgs["Connection"]["Protocol"] = str("")
                dctMsgs["Connection"]["MQTTRemoteIP"] = str("")
                dctMsgs["Connection"]["MQTTPort"] = str("")
                dctMsgs["Connection"]["ZeroMQRemoteIP"] = str("")
                dctMsgs["Connection"]["ZeroMQPort"] = str("")
                dctMsgs["Connection"]["ZeroMQRemoteIPPub"] = str("")
                dctMsgs["Connection"]["ZeroMQPortPub"] = str("")
                dctMsgs["Connection"]["xmlFile"] = str("")
                dctMsgs["Connection"]["SystemName"] = str("")
                dctMsgs["Connection"]["xmlSchema"] = str("")
                dctMsgs["Connection"]["Destination"] = str("")
                dctMsgs["Messages"] = {}

                lstClassContents = []

                try:
                    objNewModule = importlib.import_module("Codegen.Codegen_Python.Generated_Python.%s" % (lstFiles[i][:-3]))
                except Exception as E:
                    logging.error("Could not import_module %s error -> %s", 'Generated_Python.' + lstFiles[i][:-3], E)
                    continue

                # inspect a class, get its content, and append it to a list
                for name, clsClassContent in inspect.getmembers(objNewModule):
                    if inspect.isclass(clsClassContent):
                        if(
                            name.endswith("MsgCls")
                        ):
                            lstClassContents.append(clsClassContent)

                # create object of each inspected class and get its content 
                for clsClassContent in lstClassContents:
                    try:
                        objClassContent = clsClassContent()
                    except Exception as E:
                        logging.error("Cant create the object of this xml error -> %s", E)
                        return
                    try:
                        MsgName             = objClassContent.__class__.__name__[1:-6]
                        MsgType = objClassContent.sMsgHeader.u2MsgType.Value
                        acTempModuleAddress = objClassContent.sMsgHeader.u2ModuleAddress.Value
                        acModuleAddress = acTempModuleAddress
                        MsgId = objClassContent.sMsgHeader.u2MsgId.Value
                    except Exception as E:
                        logging.error('error reading xml object, error -> %s', E)
                        return

                    bPublishTag = False
                    bSubscribeTag = False
                    try:
                        if MsgName in G_dctInterfaceMessages["Publish"]:
                            if G_dctInterfaceMessages["Publish"][MsgName][2] == "MQTT" and bUseMQTT or G_dctInterfaceMessages["Publish"][MsgName][2] == "ZMQ" and bUseZMQPub:
                                bPublishTag = True
                                dctMsgs["Connection"]["PipeName"] = acPipeNamePar
                                dctMsgs["Connection"]["Protocol"] = G_dctInterfaceMessages["Publish"][MsgName][2]
                                dctMsgs["Connection"]["MQTTRemoteIP"] = acMQTTRemoteIpPar
                                dctMsgs["Connection"]["MQTTPort"] = acMQTTPortPar
                                dctMsgs["Connection"]["ZeroMQRemoteIP"] = acZeroMQRemoteIpPar
                                dctMsgs["Connection"]["ZeroMQPort"] = acZeroMQPortPar
                                dctMsgs["Connection"]["ZeroMQRemoteIPPub"] = acZeroMQRemoteIpParPub
                                dctMsgs["Connection"]["ZeroMQPortPub"] = acZeroMQPortParPub
                                dctMsgs["Connection"]["xmlFile"] = lstFiles[i][:-3]
                                dctMsgs["Connection"]["SystemName"] = G_dctInterfaceMessages["Publish"][MsgName][0]
                                dctMsgs["Connection"]["xmlSchema"] = acXmlSchemaForInterface
                                dctMsgs["Connection"]["Destination"] = G_dctInterfaceMessages["Publish"][MsgName][1]

                                dctMsgs['Messages'].update({"{}_{}_{}".format(MsgId, acTempModuleAddress, MsgType): {
                                    'Name': MsgName,
                                    'Msg_Topic': str(),
                                    'Msg_Topic_Sub':str(),
                                    'Individual_Message_Protocol':G_dctInterfaceMessages["Publish"][MsgName][2],
                                    'pubSub_tag':str(),
                                    'pubSub_tag_Sub':str(),
                                    'payloadtypes':str(''.join(recursiveGetPayloadType(list(), objClassContent.sPayload))),
                                    'Header': {
                                        'MsgLength': objClassContent.sMsgHeader.u2MsgLength.Value,
                                        'MsgType': MsgType,
                                        'MsgStatus': objClassContent.sMsgHeader.u2MsgStatus.Value,
                                        'ModuleAddress': acTempModuleAddress,
                                        'MsgId': MsgId                          
                                        },
                                    'Payload': objClassContent.sPayload}})

                                iMessageLength = iBR12HeaderLength
                                try:
                                    dctMsgs['Messages'][str(MsgId) + '_' + str(acTempModuleAddress) + '_' + str(MsgType)]['Header']['MsgLength'] = int(iGetSize(objClassContent.sPayload))
                                except Exception as E:
                                    logging.error("Unable to update the message length, error -> %s", E)


                                lstRoles = objClassContent.roles.split(",")
                                if len(lstRoles) > 1:
                                    if lstRoles:
                                        for role in lstRoles:
                                            dctMsgs['Messages'].update({"{}_{}_{}_{}".format(MsgId, acTempModuleAddress, MsgType, role): {
                                                'Name': MsgName + '_' + role,
                                                'Msg_Topic': str(),
                                                'Msg_Topic_Sub':str(),
                                                'Individual_Message_Protocol':G_dctInterfaceMessages["Publish"][MsgName][2],
                                                'pubSub_tag':str(),
                                                'pubSub_tag_Sub':str(),
                                                'payloadtypes':str(''.join(recursiveGetPayloadType(list(), objClassContent.sPayload))),
                                                'Header': {
                                                    'MsgLength': objClassContent.sMsgHeader.u2MsgLength.Value,
                                                    'MsgType': MsgType,
                                                    'MsgStatus': objClassContent.sMsgHeader.u2MsgStatus.Value,
                                                    'ModuleAddress': acTempModuleAddress,
                                                    'MsgId': MsgId                          
                                                    },
                                                'Payload': objClassContent.sPayload}})
                                            
                                            iMessageLength = iBR12HeaderLength
                                            try:
                                                dctMsgs['Messages'][str(MsgId) + '_' + str(acTempModuleAddress) + '_' + str(MsgType) + '_' + role]['Header']['MsgLength'] = int(iGetSize(objClassContent.sPayload))
                                            except Exception as E:
                                                logging.error("Unable to update the message length, error -> %s", E)
                        if MsgName in G_dctInterfaceMessages["Subscribe"]:
                            if G_dctInterfaceMessages["Subscribe"][MsgName][2] == "MQTT" and bUseMQTT or G_dctInterfaceMessages["Subscribe"][MsgName][2] == "ZMQ" and bUseZMQSub:
                                bSubscribeTag = True
                                dctMsgs["Connection"]["PipeName"] = acPipeNamePar
                                dctMsgs["Connection"]["Protocol"] = G_dctInterfaceMessages["Subscribe"][MsgName][2]
                                dctMsgs["Connection"]["MQTTRemoteIP"] = acMQTTRemoteIpPar
                                dctMsgs["Connection"]["MQTTPort"] = acMQTTPortPar
                                dctMsgs["Connection"]["ZeroMQRemoteIP"] = acZeroMQRemoteIpPar
                                dctMsgs["Connection"]["ZeroMQPort"] = acZeroMQPortPar
                                dctMsgs["Connection"]["ZeroMQRemoteIPPub"] = acZeroMQRemoteIpParPub
                                dctMsgs["Connection"]["ZeroMQPortPub"] = acZeroMQPortParPub
                                dctMsgs["Connection"]["xmlFile"] = lstFiles[i][:-3]
                                dctMsgs["Connection"]["SystemName"] = G_dctInterfaceMessages["Subscribe"][MsgName][0]
                                dctMsgs["Connection"]["xmlSchema"] = acXmlSchemaForInterface
                                dctMsgs["Connection"]["Destination"] = G_dctInterfaceMessages["Subscribe"][MsgName][1]

                                dctMsgs['Messages'].update({"{}_{}_{}".format(MsgId, acTempModuleAddress, MsgType): {
                                    'Name': MsgName,
                                    'Msg_Topic': str(),
                                    'Msg_Topic_Sub':str(),
                                    'Individual_Message_Protocol':G_dctInterfaceMessages["Subscribe"][MsgName][2],
                                    'pubSub_tag':str(),
                                    'pubSub_tag_Sub':str(),
                                    'payloadtypes':str(''.join(recursiveGetPayloadType(list(), objClassContent.sPayload))),
                                    'Header': {
                                        'MsgLength': objClassContent.sMsgHeader.u2MsgLength.Value,
                                        'MsgType': MsgType,
                                        'MsgStatus': objClassContent.sMsgHeader.u2MsgStatus.Value,
                                        'ModuleAddress': acTempModuleAddress,
                                        'MsgId': MsgId                          
                                        },
                                    'Payload': objClassContent.sPayload}})

                                iMessageLength = iBR12HeaderLength
                                try:
                                    dctMsgs['Messages'][str(MsgId) + '_' + str(acTempModuleAddress) + '_' + str(MsgType)]['Header']['MsgLength'] = int(iGetSize(objClassContent.sPayload))
                                except Exception as E:
                                    logging.error("Unable to update the message length, error -> %s", E)

                                lstRoles = objClassContent.roles.split(",")
                                if len(lstRoles) > 1:
                                    if lstRoles:
                                        for role in lstRoles:
                                            dctMsgs['Messages'].update({"{}_{}_{}_{}".format(MsgId, acTempModuleAddress, MsgType, role): {
                                                'Name': MsgName + '_' + role,
                                                'Msg_Topic': str(),
                                                'Msg_Topic_Sub':str(),
                                                'Individual_Message_Protocol':G_dctInterfaceMessages["Subscribe"][MsgName][2],
                                                'pubSub_tag':str(),
                                                'pubSub_tag_Sub':str(),
                                                'payloadtypes':str(''.join(recursiveGetPayloadType(list(), objClassContent.sPayload))),
                                                'Header': {
                                                    'MsgLength': objClassContent.sMsgHeader.u2MsgLength.Value,
                                                    'MsgType': MsgType,
                                                    'MsgStatus': objClassContent.sMsgHeader.u2MsgStatus.Value,
                                                    'ModuleAddress': acTempModuleAddress,
                                                    'MsgId': MsgId                          
                                                    },
                                                'Payload': objClassContent.sPayload}})
                                            
                                            iMessageLength = iBR12HeaderLength
                                            try:
                                                dctMsgs['Messages'][str(MsgId) + '_' + str(acTempModuleAddress) + '_' + str(MsgType) + '_'+role]['Header']['MsgLength'] = int(iGetSize(objClassContent.sPayload))
                                            except Exception as E:
                                                logging.error("Unable to update the message length, error -> %s", E)


                        lstRoles = objClassContent.roles.split(",")
                        if bPublishTag == True:
                            acID = str(MsgId) + "_" + str(acTempModuleAddress) + "_" + str(MsgType)
                            dctMsgs['Messages'][acID]["Msg_Topic"] = G_dctInterfaceMessages["Publish"][MsgName][0] + '/' + G_dctInterfaceMessages["Publish"][MsgName][1] + '/' + MsgName
                            dctMsgs['Messages'][acID]["pubSub_tag"] = G_dctInterfaceMessages["Publish"][MsgName][4]
                            if len(lstRoles) > 1:
                                if lstRoles:
                                    for role in lstRoles:
                                        acID = str(MsgId) + "_" + str(acTempModuleAddress) + "_" + str(MsgType) + "_" + str(role)
                                        dctMsgs['Messages'][acID]["Msg_Topic"] = G_dctInterfaceMessages["Publish"][MsgName][0] + '/' + G_dctInterfaceMessages["Publish"][MsgName][1] + '/' + MsgName +'/'+role
                                        dctMsgs['Messages'][acID]["pubSub_tag"] = G_dctInterfaceMessages["Publish"][MsgName][4]
                            

                        if bSubscribeTag == True:
                            acID = str(MsgId) + "_" + str(acTempModuleAddress) + "_" + str(MsgType)
                            dctMsgs['Messages'][acID]["Msg_Topic_Sub"] = G_dctInterfaceMessages["Subscribe"][MsgName][0] + '/' + G_dctInterfaceMessages["Subscribe"][MsgName][1] + '/' + MsgName
                            dctMsgs['Messages'][acID]["pubSub_tag_Sub"] = G_dctInterfaceMessages["Subscribe"][MsgName][4]
                            if len(lstRoles) > 1:
                                if lstRoles:
                                    for role in lstRoles:
                                        acID = str(MsgId) + "_" + str(acTempModuleAddress) + "_" + str(MsgType) + "_" + str(role)
                                        dctMsgs['Messages'][acID]["Msg_Topic_Sub"] = G_dctInterfaceMessages["Subscribe"][MsgName][0] + '/' + G_dctInterfaceMessages["Subscribe"][MsgName][1] + '/' + MsgName +'/'+role
                                        dctMsgs['Messages'][acID]["pubSub_tag_Sub"] = G_dctInterfaceMessages["Subscribe"][MsgName][4]

                    except Exception as E:
                        logging.error("Could not read the message protocol from the dictionary, Error -> %s", E)
                    
                dctMsgsCopy = copy.deepcopy(dctMsgs)
                _Protocol_class.G_dctJsonFile['xmls'].append(dctMsgsCopy)
                _Protocol_class.G_dctJsonFileSender['xmls'].append(dctMsgsCopy)


        newPipes = copy.deepcopy({str(acModuleAddress):{'name':acPipeNamePar,'xmls':lstxmlsPar}})
        _Protocol_class.G_dctPipes.update(newPipes)

        try:
            _Protocol_class.G_dctJsonFile = OrderedDict(json.loads(json.dumps(_Protocol_class.G_dctJsonFile)))
            _Protocol_class.G_dctJsonFileSender = OrderedDict(json.loads(json.dumps(_Protocol_class.G_dctJsonFileSender)))
        except Exception as E:
            logging.error("Could not convert dictionary to json string and back to dictionary, Error -> %s", E)


def recursiveGetPayloadType(lstMessageTypes, lstMsgs):
    """ this method is used to recursively get types of all fields in the payload

        Args:
            lstMsgs (list): list of message payload -> field of base, enums and struct

        Returns:
            self.lstMessageTypes (list): list of all field types
        Raises:
            Raises no exceptions
    """

    TypeDict = {
        'ST': 's',
        'CH': 's',
        'I1': 'b',
        'I2': 'h',
        'I4': 'i',
        'I8': 'q',
        'U1': 'B',
        'U2': 'H',
        'U4': 'I',
        'U8': 'Q',
        'F4': 'f',
        'F8': 'd'
    }

    if type(lstMsgs) == list: 
        for field in lstMsgs:
            """ 
                if a field has a type and a message, then it is either a base or
                an enum. else if the field has a key 'members', then the field is
                a structure, and you must recurse the structure to get all field
                of the structure
            """
            if "type" in field and "value" in field:
                """
                    if the length of lstMessageTypes is equal to zero, then it
                    is the first field to append,
                """
                if len(lstMessageTypes) > 0:
                    if field['type'] == 'CH':
                        try:
                            lstMessageTypes.append(str(field['count']) + TypeDict[field['type']]) #if type is CH, append count number when packing
                        except Exception as E:
                            logging.error("Error pappending the type, error -> %s", E)
                    elif field['type'] != 'CH':
                        """
                            check the size of the last element of list, if the element is equal to '1'
                            Then there is one char, else the is a char with a number of chars already appended
                        """
                        if len(lstMessageTypes[-1]) == 1:
                            """
                                Only 1 char, with no number eg -> ['H','2B','I']
                                If the last element of lstMessageTypes is the same as the current field Type,
                                replace the last char with 2+char, if they are not the same, simply append
                                the current field Type char to the lstMessageTypes.
                            """
                            if lstMessageTypes[-1] == TypeDict[field['type']]:
                                try:
                                    lstMessageTypes[-1] = str(2) + TypeDict[field['type']]
                                except Exception as E:
                                    logging.error("Could not replace the last element of the list, error -> %s", E)
                            elif lstMessageTypes[-1] != TypeDict[field['type']]:
                                try:
                                    lstMessageTypes.append(TypeDict[field['type']])
                                except Exception as E:
                                    logging.error("Could not append to the list, error -> %s", E)

                        elif len(lstMessageTypes[-1]) > 1:
                            """
                                more than 1 char on last element eg -> ['H','2B','3I']
                                get the last element, separate the number and the char
                            """
                            acNumberAndType = lstMessageTypes[-1]
                            iNumber = int(acNumberAndType[:-1])
                            acType = acNumberAndType[-1]
                            iNewNumber = int(iNumber) + 1
                            acNewValue = str(iNewNumber) + acType

                            if acType == TypeDict[field['type']]:
                                lstMessageTypes[-1] = acNewValue
                            elif lstMessageTypes[-1] != TypeDict[field['type']]:
                                lstMessageTypes.append(TypeDict[field['type']])
                elif len(lstMessageTypes) == 0:
                    if field['type'] == 'CH':
                        """
                            if type is CH, append count number when packing
                        """
                        try:
                            lstMessageTypes.append(str(field['count']) + TypeDict[field['type']])
                        except Exception as E:
                            logging.error("Error appending the type, error -> %s", E)
                    else:
                        try:
                            lstMessageTypes.append(TypeDict[field['type']])
                        except Exception as E:
                            logging.error("Error appending the type, error -> %s", E)
            if 'members' in field:
                recursiveGetPayloadType(lstMessageTypes, field["members"])
    return lstMessageTypes


def iGetSize(lstPayloadPar):
    """ this method calculates the size of the message

        Args:
            lstPayloadPar (list): list of message payload -> field of base, enums and struct

        Returns:
            msgLength (int): length of the message
        Raises:
            Raises no exceptions
    """
    global iMessageLength
    dctTypeSize = {
        'ST': 's',
        'CH': 's',
        'I1': '1',
        'I2': '2',
        'I4': '4',
        'I8': '8',
        'U1': '1',
        'U2': '2',
        'U4': '4',
        'U8': '8',
        'F4': '4',
        'F8': '8'
    }
    
    if type(lstPayloadPar) == list: 
        for field in lstPayloadPar:
            if "type" in field and "value" in field:
                if field['type'] == 'CH' or field['type'] == 'ST':
                    try:
                        iMessageLength += int(field['count'])
                    except Exception as E:
                        logging.error("Error getting the CH count, error -> %s", E)
                else:
                    try:
                        iMessageLength += int(dctTypeSize[field['type']])
                    except Exception as E:
                        logging.error("Error appending the field size, error -> %s", E)
                
            if 'members' in field:
                iGetSize(field["members"])
    return iMessageLength

def getPipes():
    '''
        Oopen pipes file and return the file in dictionary format
    '''
    return _Protocol_class.G_dctPipes

def getXmls():
    '''
        Return list of xmls from SICD folder
    '''
    xmlPath = os.path.join(os.path.dirname(__file__), "../../SICD/")
    xmlFiles = os.listdir(xmlPath)
    lstXmls = []
    for i in range(len(xmlFiles)):
        if xmlFiles[i].endswith('Msg.xml'):
            lstXmls.append(xmlFiles[i])
    return lstXmls

def getInterfaceXmls():
    '''
        Return list of Interface xmls from SICD folder
    '''
    xmlPath = os.path.join(os.path.dirname(__file__), "../../SICD/")
    xmlFiles = os.listdir(xmlPath)
    lstInterfaceXmls = []
    for i in range(len(xmlFiles)):
        if xmlFiles[i].startswith('Module_Interface_Config_'):
            lstInterfaceXmls.append(xmlFiles[i])
    return lstInterfaceXmls    

def getReceivedMsgs():
    '''
        Return number of received messages in dictionary format
    '''
    data = {}
    path = os.path.join(os.path.dirname(__file__), "../../Structure/")
    lstFiles = os.listdir(path)
    for i in range(len(lstFiles)):
        if lstFiles[i] == ('receivedMsgs.json'):
            with open(path + lstFiles[i], 'r') as f:
                data = OrderedDict(json.load(f))
                f.close()
    return data

def getCheckedMsgs():
    '''
        Return favourate messages in dictionary format
    '''
    return _Protocol_class.G_dctFavourites

def getLog():
    '''
        Open the log file and return the log
    '''
    data = ''
    path = os.path.join(os.path.dirname(__file__), "../../")
    lstFiles = os.listdir(path)
    for i in range(len(lstFiles)):
        if lstFiles[i] == ('Subscriptions.log'):
            with open(path + lstFiles[i], 'r') as f:
                data = f.read()
                f.close()
    return data

def getRecordingMsgs():
    '''
        Return messages that are recording
    '''
    data = ''
    path = os.path.join(os.path.dirname(__file__), "../../Structure/")
    lstFiles = os.listdir(path)
    for i in range(len(lstFiles)):
        if lstFiles[i] == ('messagesToRecord.json'):
            with open(path + lstFiles[i], 'r') as f:
                data = f.read()
                f.close()
    return data

def getRecordedMessages():
    '''
        Return recorded messages
    '''
    return _Protocol_class.G_dctRecordedMessages


def getdctFieldVal():
    '''
        Return list of received messages
    '''
    data = ''
    path = os.path.join(os.path.dirname(__file__), "../../Structure/")
    lstFiles = os.listdir(path)
    for i in range(len(lstFiles)):
        if lstFiles[i] == ('dctFieldVal.json'):
            with open(path + lstFiles[i], 'r') as f:
                data = f.read()
                f.close()
    return data


def downloadFile(fileName):
    '''
        Return file data
    '''
    data = ''
    path = os.path.join(os.path.dirname(__file__), "../../record/json/")
    lstFiles = os.listdir(path)
    for i in range(len(lstFiles)):
        if lstFiles[i] == (fileName):
            with open(path + lstFiles[i], 'r') as f:
                data = f.read()
                f.close()
    return data

def downloadCsvFile(fileName):
    '''
        Return csv file data
    '''
    data = ''
    path = os.path.join(os.path.dirname(__file__), "../../record/csv/")
    lstFiles = os.listdir(path)
    for i in range(len(lstFiles)):
        if lstFiles[i] == (fileName):
            with open(path + lstFiles[i], 'r') as f:
                data = f.read()
                f.close()
    return data